<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ORB_SLAM2 在 Windows 下编译]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%2F%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%2Forb-slam2%2F</url>
    <content type="text"><![CDATA[本文是针对ORB_SLAM2在Windows操作系统上如何编译和运行的一些说明。主要步骤说明在编译流程一节。 参考资料[1]《深入理解图优化与g2o》[2]《Yarten - CSDN博客》[3]《Fix Visual Studio 2013 crashes #56 - g2o/issues》[4]《Fatal Error C1001》 必要组件编译ORB_SLAM2之前需要以下第三方组件，这些组件可以从Github上克隆： Eigen3：用来进行线性代数、矩阵、向量操作等运算的C++类库，基于模板因此没有.lib文件，只需引入头文件。 OpenCV：用来处理计算机图像且包含计算机视觉算法的C++类库。 DBoW2：用于将图像转换为低维向量的压缩信息的类库，通过这种方式能够更简单比较两个图像之间的相似度。 g2o：用于图优化的C++类库。 Pangolin：基于OpenGL的封装类库，能够处理视频输入和输出。 可选组件由于ORB_SLAM2中自带了修改过的DBoW2和g2o库，如果需要自己去克隆和编译（不推荐）DBoW2和D Boost：STL的延伸，基于STL提供的算法封装工具类，可以用于完成比较具体的工作。 编译基础在Windows操作系统上进行编译时，需要注意以下几点： 检查工程文件内的CMakeList.txt文件，如果存在FIND_PACKAGE语句则直接删除。对于TARGET_LINK_LIBRARIES和INCLUDE_DIRECTORIES等指令，可以将里面包含的CMake变量改成系统环境变量（即$ENV{}格式的变量）。 使用CMake构建工程时，尽量构建X64模式的工程，如下通过Win64的方式来指定目标平台： 12# ../src/buildcmake .. -G "Visual Studio 15 2017 Win64" 在编译之前，确保项目属性中C/C++标签内的命令行选项、链接器（或者库管理器）标签内的命令行选项内是否包含/machine参数，需要统一成/machine:X64。 编译流程安装CMakeCMake作为一种项目管理工具，可以从官方网站下载和安装。安装后可以通过命令提示符或图形界面（CMake GUI）来针对克隆下来的CMakeList.txt进行项目构建。CMake的具体使用方式可以参考CMake教程。 编译OpenCV编译OpenCV的过程通常没有太多的问题，只需要注意在Release X64模式下编译成功，并且使用多线程MT运行库。实际上目前还是推荐从OpenCV官网上下载最新版的编译好的二进制文件。 编译Pangolin编译Pangolin的过程建议通过以下步骤进行： 通过CMake构建X64工程文件，注意如果提示file problem creating directory错误，需要手动去C:/Program Files文件夹内新建Pangolin文件夹。 构建完毕后，确保使用管理员权限打开工程文件，这样才能确保__glew、__zlib、__libjpeg、__libpng等工程正确编译，防止出现MSB3073错误。 选择目标为Relase X64，运行库设置为多线程MT，并且将pangolin项目设为启动项目。 设置pangolin的附加包含目录，如下，其中${Pangolin}代表克隆后的Pangolin工程根目录： ${Pangolin}/include ${Pangolin}/build/src/include C:/Program Files/Pangolin/include，该文件夹为空，可以不包含。 ${Pangolin}/build/external/glew/src/__glew/include，如果不包含不提示错误，可以不包含。 右键点击重新生成，或者点击本地Windows调试器，进行Pangolin的生成过程。 编译过程中可能会发生以下的问题： C1083 无法打开包括文件：jconfig.h：No such file or directory 解决方法：将${Pangolin}/build/external/libjpeg/src/__libjpeg/文件夹内的jconfig.txt文件改成jconfig.h。 C1083 无法打开包括文件：pnglibconf.h：No such file or directory 解决方法：从Github上获取pnglibconf.h文件，并放到${Pangolin}/build/external/libpng/src/__libpng文件夹中。 编译Eigen3该工程是基于模板的工程，只需要作为包含目录引用即可，不需要进行编译和引用依赖库。 编译DBoW2这里建议使用ORB_SLAM2自带的DBoW2类库，该类库针对ORB_SLAM2进行了修改。而编译该类库需要以下几种步骤： 通过CMake构建X64工程文件，注意构建之前在CMakeList.txt文件中寻找有关OpenCV的FIND_PACKAGE指令并删除，然后建议通过INCLUDE_DIRECTORIES和TARGET_LINK_LIBRARIES指令中添加OpenCV的包含目录和依赖库目录。 打开工程文件，选择目标为Release X64，运行库设置为多线程MT，在命令行中，并且将DBoW2设置为启动项目。 确保OpenCV的头文件和依赖库正确添加。 创建并编写一个DBoW2Exports.h头文件用于API声明，如下，使用宏定义之前需要保证在工程属性的预处理器一项中添加预处理器定义DBOW2_EXPORTS来确保API声明生效： 123456#pragma once#ifdef DBOW2_EXPORTS#define DBOW2_API __declspec(dllexport)#else#define DBOW2_API __declspec(dllimport)#endif 对工程内的头文件添加API声明，针对以下类型将声明class XXX改为class DBOW2_API XXX： BowVector.h：修改BowVector类。 FeatureVector.h：修改FeatureVector类。 FORB.h：修改FORB类。 Random.h：修改Random、UnrepeatedRandomizer等类。 ScoringObjects.h：修改GeneralScoring类型，并且修改所有前缀为__SCORING_CLASS宏的类型。 Timestamp.h：修改Timestamp类。 右键点击DBoW2项目并重新生成，或者点击本地Windows调试器来编译工程。 编译过程中可能会发生以下问题： C1083 无法打开包括文件：stdint-gcc.h：No such file or directory 解决方法：将stdint-gcc.h改为stdint.h。 编译g2o这里建议使用ORB_SLAM2自带的g2o类库，该类库针对ORB_SLAM2进行了修改。而编译该类库需要以下几种步骤： 通过CMake构建X64工程文件，注意构建之前在CMakeList.txt文件中寻找有关Eigen的FIND_PACKAGE指令并删除，然后建议通过INCLUDE_DIRECTORIES和TARGET_LINK_LIBRARIES指令中添加Eigen的包含目录。 打开工程文件，选择目标为Release X64，运行库设置为多线程MT，并且将g2o设置为启动项目。 打开C/C++中的命令行页面，删除/W参数。 找到sparse_block_matrix.hpp、sparse_block_matrix_diagonal.h、matrix_operations.h等文件，修改如下模板函数，避免Visual Studio在编译过程中无法识别具体类型而报C1001错误： 1234567// sparse_block_matrix.hpp, Line 273// internal::axpy(*a, srcVec, srcOffset, destVec, destOffset);internal::template axpy&lt;typename SparseBlockMatrix&lt;MatrixType&gt;::SparseMatrixBlock&gt;(*a, srcVec, srcOffset, destVec, destOffset);// sparse_block_matrix.hpp, Line 275// internal::atxpy(*a, srcVec, destOffset, destVec, srcOffset);internal::template atxpy&lt;typename SparseBlockMatrix&lt;MatrixType&gt;::SparseMatrixBlock&gt;(*a, srcVec, destOffset, destVec, srcOffset);// matrix_operations.h, 49 如果存在matrix_operations.h文件，则按照第四步的步骤在文档中查找axpy()和atxpy()，并且同样修改成第四步中指定的内容。 修改config.h头文件用于API声明（如果config.h不存在，则将config.txt后缀改为.h），如下，使用宏定义之前需要保证在工程属性的预处理器一项中添加预处理器定义G2O_EXPORTS来确保API声明生效： 123456#pragma once#ifdef G2O_EXPORTS#define G2O_API __declspec(dllexport)#else#define G2O_API __declspec(dllimport)#endif 对工程内的头文件引入config.h且添加API声明，针对类型声明class XXX改为class G2O_API XXX，结构体声明struct XXX改为struct G2O_API XXX，注意这里只需要对有对应.cpp而没有对应.hpp文件的头文件进行修改即可： bathc_stats.h：修改G2OBatchStatistics结构体。 cache.h：修改CacheContainer、Cache等类。 creators.h：修改AbstractHyperGraphElementCreator、HyperGraphElementCreator等类。 estimate_propagator.h：修改EstimatePropagatorCost、EstimatePropagatorCostOdometry、EstimatePropagator等类。 factory.h：修改AbstractHyperGraphElementCreator、Factory、RegisterTypeProxy等类。 hyper_dijkstra.h：修改HyperDijkstra、UniformCostFunction等结构体。 hyper_graph.h：修改HyperGraph类。 hyper_graph_action.h：修改HyperGraphAction、HyperGraphElementAction、HyperGraphElementActionCollection、HyperGraphActionLibrary、WriteGnuplotAction、DrawAction等类型，修改RegisterActionProxy模板类。 jacobian_workspace.h：修改OptimizableGraph、JacobianWorkspace等类。 marginal_covariance_cholesky.h：修改MarginalCovarianceCholesky类。 matrix_structure.h：修改MatrixStructure类。 openmp_mutex：修改OpenMPMutex、ScopedOpenMPMutex等类。 optimizable_graph.h：修改OptimizableGraph结构体，修改HyperGraphAction、OptimizationAlgorithmProperty、Cache、CacheContainer、RobustKernel等类型。 optimization_algorithm.h：修改SparseOptimizer、OptimizationAlgorithm等类型。 optimization_algorithm_factory.h：修改OptimizationAlgorithm、SparseOptimizer、AbstractOptimizationAlgorithmCreator、OptimizationAlgorithmFactory、RegisterOptimizationAlgorithmProxy等类型。 optimization_algorithm_levenberg.h：修改OptimizationAlgorithmLevenberg等类型。 optimization_algorithm_with_hessian.h：修改Solver、OptimizationAlgorithmWithHessian等类型。 parameter.h：修改Parameter类。 parameter_container.h：修改Parameter、ParameterContainer等类。 property.h：修改BaseProperty、PropertyMap等类，修改Property模板类型。 robust_kernel.h：修改RobustKernel类。 robust_kernel_factory.h：修改RobustKernel、AbstractRobustKernelCreator、RobustKernelFactory等类型，修改RobustKernelCreator、RegisterRobustKernelProxy等模板类。 robust_kernel_impl.h：修改RobustKernelScaleDelta、RobustKernelHuber、RobustKernelTukey、RobustKernelPseudoHuber、RobustKernelCauchy、RobustKernelSaturated、RobustKernelDCS等类型。 solver.h：修改SparseOptimizer、Solver等类型。 sparse_optimizer.h：修改ActivePathCostFunction、OptimizationAlgorithm、EstimatePropagatorCost、SparseOptimizer等类型。 types_sba.h：修改VertexSBAPointXYZ类。 types_seven_dof_expmap.h：修改VertexSim3Expmap、EdgeSim3、EdgeSim3ProjectXYZ、EdgeInverseSim3ProjectXYZ等类型。 types_six_dof_expmap.h：修改VertexSE3Expmap、EdgeSE3ProjectXYZ、EdgeStereoSE3ProjectXYZ、EdgeSE3ProjectXYZOnlyPose、EdgeStereoSE3ProjectXYZOnlyPose等类型。 右键点击g2o项目并重新生成，或者点击本地Windows调试器来编译工程。 编译ORB_SLAM2编译ORB_SLAM2过程如下： 通过CMake构建X64工程文件，删除所有FIND_PACKAGE指令。 打开工程文件，选择目标为Release X64，运行库设置为多线程MT，命令行输入/machine:X64，并且将ORB_SLAM2设置为启动项目。 确认和添加相应的头文件包含目录，按顺序排列主要有： ORB_SLAM2自身的包含目录。 Eigen3的包含目录。 Pangolin的包含目录，包括${Pangolin}/include、${Pangolin}/build/src/include等目录。 DBoW2自身的包含目录和DLib的包含目录。 OpenCV的三个包含目录，也可以是一个目录但是需要调整源代码。 glew的包含目录。 g2o的包含目录，注意需要包含config.h文件。 确认和添加相应的库目录和依赖库文件，按顺序排列主要有： 系统内置依赖库，包括opengl32.lib、glu32.lib、mfplat.lib、mfreadwrite.lib、mfuuid.lib、strmiids.lib、mf.lib。 OpenCV的X64位库目录，包括opencv_world341.lib。 Pangolin工程内包含的glew库目录，包括glew.lib。 Pangolin库目录、包括pangolin.lib。 ORB_SLAM2内包含的DBoW2库目录，包括DBoW2.lib。 ORB_SLAM2内包含的g2o库目录，包括g2o.lib。 右键点击ORB_SLAM2项目并重新生成，或者点击本地Windows调试器来编译工程。 编译过程中可能会发生以下问题： 表达式必须含有常量值不可指定数组类型float [N][N] 解决方法：VC++中不允许用运行时常量去定义数组长度，因此需要进行如下修改，动态创建二维数组：12345float** Distances = new float*[N];for(int i = 0; i &lt; N; i++)&#123; Distance[i] = new float[N];&#125; ‘usleep’找不到标识符 解决方法：usleep()是在Linux上使用的函数，需要修改成以下函数中的一种：123#include &lt;thread&gt;Sleep(3000); // 单位为毫秒，需要换算微秒std::this_thread::sleep_for(std::chrono::microseconds(m)); // 可以直接替换usleep() C1083 无法打开包括文件：stdint-gcc.h：No such file or directory 解决方法：将stdint-gcc.h改为stdint.h。 C1001 编译器内部错误 解决方法：仍然是由于g2o模块中的axpy()和atxpy()方法造成的错误，请参考上方编译g2o中的第四步。 C2872 “ACCESS_MASK” 不明确的符号 解决方法：由于winnt.h和OpenCV都定义了ACCESS_MASK，如果使用using namespace cv会导致混淆，因此只能以using cv::XXX的形式引用命名空间。 示例可以在ORB_SLAM2项目中添加Main.cpp以及主函数，并且修改工程的输出类型为应用程序，最后可编译成基于ORB_SLAM2的可执行程序。 基于SLAM的AR示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include "System.h"#include "ViewerAR.h"using namespace ORB_SLAM2;using cv::VideoCapture;using cv::Mat;using cv::FileStorage;ORB_SLAM2::ViewerAR ar;bool bRGB = true;Mat K;Mat DistCoef;class ImageGrabber&#123;public: ImageGrabber(System* pSLAM) : mpSLAM(pSLAM)&#123;&#125; void GrabImage(const cv::Mat&amp; msg); System* mpSLAM;&#125;;int main()&#123; char* arg1 = "F:\\SLAM\\Source\\ORB_SLAM2\\Vocabulary\\ORBvoc.txt"; char* arg2 = "F:\\SLAM\\Source\\ORB_SLAM2\\Examples\\Monocular\\TUM2.yaml"; System orbslam(arg1, arg2, System::eSensor::MONOCULAR, true); ImageGrabber igb(&amp;orbslam); ar.SetSLAM(&amp;orbslam); FileStorage fSettings(arg2, FileStorage::READ); bRGB = static_cast&lt;bool&gt;((int)fSettings["Camera.RGB"]); float fps = fSettings["Camera.fps"]; ar.SetFPS(fps); float fx = fSettings["Camera.fx"]; float fy = fSettings["Camera.fy"]; float cx = fSettings["Camera.cx"]; float cy = fSettings["Camera.cy"]; ar.SetCameraCalibration(fx, fy, cx, cy); K = Mat::eye(3, 3, CV_32F); K.at&lt;float&gt;(0, 0) = fx; K.at&lt;float&gt;(1, 1) = fy; K.at&lt;float&gt;(0, 2) = cx; K.at&lt;float&gt;(1, 2) = cy; DistCoef = cv::Mat::zeros(4, 1, CV_32F); DistCoef.at&lt;float&gt;(0) = fSettings["Camera.k1"]; DistCoef.at&lt;float&gt;(1) = fSettings["Camera.k2"]; DistCoef.at&lt;float&gt;(2) = fSettings["Camera.p1"]; DistCoef.at&lt;float&gt;(3) = fSettings["Camera.p2"]; const float k3 = fSettings["Camera.k3"]; if (k3 != 0) &#123; DistCoef.resize(5); DistCoef.at&lt;float&gt;(4) = k3; &#125; thread tViewer = thread(&amp;ORB_SLAM2::ViewerAR::Run, &amp;ar); VideoCapture cap(0); Mat frame; bool stop = false; while (!stop) &#123; cap &gt;&gt; frame; igb.GrabImage(frame); if (cvWaitKey(30) &gt;= 0) &#123; stop = true; &#125; &#125; system("pause"); delete arg1; delete arg2; return 0;&#125;void ImageGrabber::GrabImage(const Mat&amp; msg)&#123; Mat im = msg.clone(); Mat imu; Mat Tcw = mpSLAM-&gt;TrackMonocular(msg, 0); int state = mpSLAM-&gt;GetTrackingState(); mpSLAM-&gt;TrackMonocular(msg, clock()); vector&lt;ORB_SLAM2::MapPoint*&gt; vMPs = mpSLAM-&gt;GetTrackedMapPoints(); vector&lt;cv::KeyPoint&gt; vKeys = mpSLAM-&gt;GetTrackedKeyPointsUn(); cv::undistort(im, imu, K, DistCoef); if (bRGB) &#123; cv::cvtColor(imu, imu, CV_RGB2BGR); ar.SetImagePose(imu, Tcw, state, vKeys, vMPs); &#125; else &#123; cv::cvtColor(imu, imu, CV_RGB2BGR); ar.SetImagePose(imu, Tcw, state, vKeys, vMPs); &#125;&#125; 文件解析 cv_bridge.h：ROS图像与OpenCV图像之间的转换]]></content>
      <categories>
        <category>计算机科学</category>
        <category>机器视觉</category>
      </categories>
      <tags>
        <tag>ORB_SLAM2</tag>
        <tag>SLAM</tag>
        <tag>机器视觉</tag>
        <tag>计算机科学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewRO知识库首页]]></title>
    <url>%2Funcategorized%2Fhome%2F</url>
    <content type="text"><![CDATA[欢迎来到ViewRO知识库首页，该页面旨在分享一些知识。这些知识大多来自于互联网，其余部分来自各种书籍。部分内容可能会比较初级，目的在于统一编辑和方便查找，利于内部人员和感兴趣的人避免踩坑。主要分享计算机相关的知识，未来会分享不同领域的内容。提前感谢各位巨人，一切都是因为站在巨人的肩膀上，所以才能看的更远。希望您活用本站内容。]]></content>
  </entry>
</search>
