<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[面向对象的设计原则]]></title>
    <url>%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2Fdesign-principal%2F</url>
    <content type="text"><![CDATA[概论无论是进行软件体系结构设计，或者是在高层次进行抽象，有以下几种设计原则能够帮助开发者写出更好的代码： 面向接口编程：避免面向实现编程，尽量使用OOP原则写出可扩展性强的代码。在系统分析和架构中，分清层次和依赖关系，每个层次不是直接向其上层提供服务（即不是直接实例化在上层中），而是通过定义一组接口，仅向上层暴露其接口功能，上层对于下层仅仅是接口依赖，而不依赖具体类。 面向接口编程思想与面向对象不冲突，而与面向实现冲突。面向实现意味着强烈的依赖关系，基于这种思想下的变量都指向特定类型的实例，且这些类型之间将没有任何关系。 面向接口编程中的接口，并不指代具体的interface关键字相关的内容，而是指代任意的暴露的公共成员。 SOLID原则SOLID原则是面向对象编程和变相对象设计的五个基本原则，当这些原则一起被应用时，能够使得程序更加容易维护和扩展，分别如下所示： S（The Single Responsibility Principle，单一职责原则）：每个类型应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。但是在某些特殊情况下，因为某种原因，职责不得不被分化成粒度更细的多个职责，这个现象为职责扩散。这时我们需要确保的是，虽然不能再保持类型的单一职责，但是仍然需要保持方法的单一职责。 O（The Open Closed Principle，开放封闭原则）：实体对扩展（Extension）开放，对修改（Modification）原有代码保持封闭。这里的扩展指的是新增类型，修改已有的功能只需要修改对应的类型，避免对已有实体造成影响。 L（Liskov Substitution Principle，里氏替换原则）：一个对象出现在任何地方时，都可以用子类实例作为替换，而且不会导致程序错误。 举例：正方形不是长方形的子类，正方形通过平方求得面积，且其边长相等。而长方形边长不等，且通过长宽乘积求得面积。如果使用长方形实例替换正方形实例则会导致实际结果与预期不符。 I（The Interface Segregation Principle，接口分离原则）：不能强迫依赖不使用的方法，如果在一个类实现的接口中包含了它不需要的方法，则需要将接口拆分成更小和更具体的接口。这里的不需要指不进行任何操作的方法。 D（The Dependency Inversion Principle，依赖倒置原则）：高层次模块不应该依赖低层次模块，应该都依赖于抽象。并且抽象不应该依赖于具体实现。 举例：如果A类依赖B类，该情况下A类是高层次模块（可能负责复杂的业务逻辑），B类是低层次模块（负责原子操作）。当需要把A类依赖B类的部分修改成依赖C类时，则必须要通过修改A类的代码，导致不必要的风险。因此需要让A类依赖某个接口I，而B类和C类则分别去实现接口I。 参考资料[1]https://juejin.im/entry/59e07b52f265da432a7a98b4?utm_source=gold_browser_extension[2]https://www.cnblogs.com/wuyuegb2312/p/7011708.html[3]https://blog.csdn.net/zhengzhb/article/details/7289269]]></content>
      <categories>
        <category>设计模式</category>
        <category>设计原则</category>
      </categories>
      <tags>
        <tag>面向对象设计</tag>
        <tag>设计模式</tag>
        <tag>SOLID原则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#中的委托]]></title>
    <url>%2F%E5%BC%80%E5%8F%91%2FC%2Fcsharp-delegate%2F</url>
    <content type="text"><![CDATA[参考资料 http://www.cnblogs.com/buptzym/archive/2013/03/15/2962300.html http://www.cnblogs.com/kingsanity/p/6158829.html 概念委托委托（Delegate）类似于函数指针（不同的是函数指针只能指向static方法），但是受控制并且更安全。委托是一个能持有某个方法的类，表示对具有返回类型和参数列表的方法的引用，能够将方法包装成实体传递给其他方法。C#中的委托也是回调（Callback）的基础。委托的声明来自于System.Delegate类，该类用sealed修饰且不可继承。委托对象通常有以下几个成员： Target对象：Object类型，指向回调函数的实例，委托中的方法为静态方法时为null。 Method对象：MethodInfo类型，指向回调函数。 Invoke方法：同步执行委托。 BeginInvoke方法：开始执行异步委托。 EndInvoke方法：结束异步委托。 委托可以不接收参数，至多可以接收32个参数。一个委托的简单用例如下所示，下面的用例中用到了同步执行Invoke()和异步执行BeginInvoke()，可以注意到委托可以接收实例方法和静态方法：12345678910111213141516171819202122232425262728293031// 两种相同的委托， 都只接受一个参数public delegate int FuncA(int x);public delegate int FuncB(int x);// 以下是几个普通的方法public int DelegateFunc(int x)&#123; // 实例方法 // ...&#125;public static int StaticFunc(int x)&#123; // 静态方法 // ...&#125; public void EndDelegation(object o)&#123; // 停止异步调用的方法 // ... Thread.Sleep(3000);&#125;// 使用同步委托FuncA fa = new FuncA(obj.DelegateFunc); // 传递实例方法FuncB fb = new FuncB(StaticFunc); // 传递静态方法Console.WriteLine(fa.Target.toString()); // 显示实例方法的目标实例fa.Invoke(1);fb.Invoke(2);// 使用异步委托IAsyncResult rs = fa.BeginInvoke(3, new AsyncCallback(p.EndDelegation), null); // 异步调用，3秒后调用回调方法fa.EndInvoke(rs); // 结束调用 BeginInvoke()接收了三个参数，实际上参数数量是根据委托本身所接收的参数数量而进行改变的，唯一不变的是最后两个参数：AsyncCallback对象和Object对象。AsyncCallback对象当做回调函数使用，通常在委托执行完毕后执行；而最后一个参数Object对象用于传递给回调函数。注意AsyncCallback类型接收的方法必须要接收一个Object对象为参数，如上述示例中的EndDelegation()。此外，一个委托对象可以绑定多个方法，可以同时绑定静态和非静态方法到一个委托对象上，不过异步启动某个委托时必须保证该委托中只有一个绑定方法。有一些特殊的泛型委托，分别是Action、Func和Predicate，这几个泛型委托是系统提供的简单的泛型委托示例但非常好用，详情请参考C#中的泛型委托。 事件事件（Event）模型建立在委托机制之上。定义事件成员的类型允许其在某些事件发生时通知其他对象。事件是一种特殊签名的委托，能够帮助我们实现类似于观察者模式等一些行为模式。事件的完整生命周期通常分以下几个部分： 定义一个委托，该委托的参数列表为(object sender, EventArgs e)，其中第二个参数可以是任何EventArgs类型对象或其派生类对象。 定义事件处理方法，该方法的参数列表也是(object sender, EventArgs e); 使用event关键字，结合之前定义的委托，声明一个事件对象，即事件订阅者。 将事件添加到事件队列中。 一个事件的简单用例如下所示：123456789101112131415161718192021222324// 一个自定义类型public class MyEvent&#123; // 一个符合事件条件的方法签名 public void MyFunc(object o, EventArgs, e)&#123; // ... &#125;&#125;class Program&#123; public delegate void MyEventHandler(object o, EventArgs e); // 委托 private event MyEventHandler myEvent; // 事件， 与委托关联 private MyEvent myEventObj; // 普通实例 public Program()&#123; myEventObj = new MyEvent(); myEvent += new MyEventHandler(myEventObj.MyFunc); // 添加事件委托 &#125; static void Main(string[] args)&#123; Program p = new Program(); p.myEvent(null, null); // 触发事件 &#125;&#125; 示例中，我们定义了一个MyEventHandler委托，myEventObj对象就是事件处理方法所在的对象，myEvent对象就是事件对象。我们把myEventObj对象中的MyFunc()方法作为事件处理方法传递给了myEvent，最后在主函数中触发了它。通常myEvent对象我们可以描述为带有事件特性的委托对象。 事件挂载和取消如果在同一个事件上挂载多次（同一个引用的方法），那么事件触发时，这些函数都会执行。除此之外事件取消订阅时，也会发生问题，例如如果多次删除同一个事件方法时，首先它并不会报错。如果多次删除，这最终事件挂载的方法为空。如果出现挂载三次删除两次的情况，那么事件触发时只会被调用一次。这种情况发生的原因在于实际上事件订阅列表是一个List类型，问题也就变成了列表中增删元素的问题，调用时也会逐个元素进行调用。 使用匿名函数进行事件挂载假设有以下一段事件挂载和取消代码：12myEvent.OnEvent += (s, e) =&gt; Console.WriteLine("Hello"); // 挂载myEvent.OnEvent -= (s, e) =&gt; Console.WriteLine("Hello"); // 取消 如果在这之后触发了事件，那么实际上就算是相同的方法，事件取消并不会成功，事件还是会被调用。形式一致的匿名函数在编译器编译时产生的方法签名可能不一致，也可能在栈中放置了两个不同的区域来分别存储这两个临时函数，因此导致的一个结论就是匿名函数无法被取消订阅。 事件的触发需要触发事件时，我们需要声明一个接口，该接口负责在声明事件的类型中调用这个事件。无法在其他类型中直接调用这个事件，其他类型中只能给事件进行挂载和取消。此外，如果事件定义了add和remove选择器，此时在同类型中也无法直接调用事件，如下所示：123456private event EventHandler&lt;EventArgs&gt; myEvent;public event EventHandler&lt;EventArgs&gt; MyEvent&#123; add &#123; myEvent = value; &#125; remove &#123; myEvent = null; &#125;&#125; 事件的回收假设有如下代码，仍然使用匿名函数来进行事件挂载：12myEvent.OnEvent += (s, e) =&gt; Console.WriteLine("Hello"); // 挂载myEvent = new MyEvent(); // 整个覆盖 如果我们随后对整个对象直接进行覆盖，那么原来的对象会被GC回收，其中的匿名函数也会被GC回收。如果采用以下这种写法：12// 假设事件已经被触发test = null; // 设为空 那么如果被触发的事件正在执行，对象设为空后，该方法也会继续执行，这是因为当一个Lambda表达式转换为委托时，编译器会执行以下操作： 编译器会生成一个临时private方法，根据目标类型不同可以是静态或实例的。 委托内部还会创建一个私有字段_target指向当前的委托实例。 上述例子中，如果test = null 但是仍然能执行事件方法的原因就在于使用Lambda表达式或匿名方法创建委托时，委托内部的_target也会指向原来事件指向的方法，即有效引用仍然存在，如果超出了代码作用域或者直接使用new关键字来覆盖原引用，这时原引用就会消失，test实例也会被GC回收掉。 多线程与事件一般来讲事件触发和事件执行是同步的。如果在事件方法内创建新的线程，或者在线程池内调用事件触发方法时，事件执行的线程与事件触发的线程不在同一个线程。事件订阅者在其他线程创建，或者在其他线程挂载事件方法，都不影响事件触发与事件执行在同一线程的情况。 EventArgs与EventHandler每个事件在调用时需要传递EventArgs或其派生类型，而.NET Framework提供了一个默认的事件处理类型，叫做EventHandler，其本质是一个泛型委托，如下所示：1public delegate void EventHandler&lt;TEventArgs&gt;(object sender, TEventArgs e) where TEventArgs : EventArgs 其中，EventHandler接收的参数中包含了一个EventArgs的派生类型。由于是委托，因此在使用时需要声明为事件。 FAQ事件与委托的区别在调用方式上两者没有区别，其中事件本质就是一种特殊的多播委托。声明事件时，会在委托的基础上添加以add和remove为前缀的方法。其中add方法对应委托的Delegate.Combine()，能够组成一个多播委托；remove方法对应委托的Delegate.Remove()，能够移除多播委托中的一个委托。而委托在进一步封装成事件后，事件中调用的委托将是一个私有成员，这样能够避免委托直接暴露，使得程序代码更加安全。 Invoke()与DynamicInvoke()委托对象提供了Invoke()和DynamicInvoke()方法，这两种方法的区别在于效率： Invoke()方法的调用将非常快，且使用前提为用户知道该委托的具体类型和具体参数。 1234Func&lt;int,int&gt; twice = x =&gt; x * 2;int i = 3;int j = twice.Invoke(i);int k = twice(i); 直接调用也可以 DynamicInvoke()方法的调用效率非常低，如果用户不知道委托的具体信息且只能解析为Delegate抽象类型对象，这时只能调用DynamicInvoke()，该过程中会发生大量的装拆箱以及反射等操作。 123Delegate slowTwice = twice; // 解析为Delegate抽象类object[] args = &#123; i &#125;; // 参数只能用object数组传递object result = slowTwice.DynamicInvoke(args); 延伸 C#中的多线程]]></content>
      <categories>
        <category>开发</category>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>委托</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[过程模型概述]]></title>
    <url>%2F%E8%BD%AF%E4%BB%B6%E8%BF%87%E7%A8%8B%2F%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B%2Fprocedure-models%2F</url>
    <content type="text"><![CDATA[传统开发模型和敏捷开发模型，实际上都是软件过程模型。 传统开发模型瀑布模型瀑布模型（Waterfall Model）属于传统软件开发模型，各个阶段如下图所示，包括：计划阶段、需求分析阶段、设计阶段、编码阶段、测试阶段、发布阶段、实施阶段以及运行维护阶段等。瀑布模型强调由上而下，互相衔接，逐级下落，次序固定。 瀑布模型拥有以下几种特点： 顺序性和依赖性：每个阶段需要等待前一阶段工作完成（输出）和评审确认，才能开始后一阶段的输入，否则返回上一个或更早的工作阶段。 推迟实现：在实际实现软件代码之前，要经过需求分析与设计阶段来完成系统逻辑模型，之后才进行编码工作。 质量保证：每个阶段都需要文档来保证质量，无文档意味着没有完成该阶段的任务，同时阶段结束前要对输出的文档进行评审。 瀑布模型拥有以下几种局限性： 输出一旦确定便不可逆。 一次性的需求调查，无法适应需求变化。 单向的开发流程，开发中的反馈和经验无法应用于当前项目。 风险在后期才开始逐渐暴露。 RAD模型（V模型）瀑布模型总是试图做好一件事情之后才做下一件事，但是错误是不可避免的。可以看出，在整个开发过程中，只有在最后的部署阶段才能让客户看到这个软件。而通常需求分析阶段是最容易出现错误的阶段，所以很可能最开始的错误会一直流传到最后才会被发现，这意味着我们必须要更改所有的活动以求改正错误，同样的问题还会出现在需求变更时。所以，瀑布模型在实际应用中常常会变为V模型，如下图所示： RAD（Rapid Application Development）模型是软件开发过程中的一个重要模型，是测试驱动模型的一种，模型构图形似V字母因此称为V模型。V模型通过开发和测试同时进行的方式来缩短开发周期，提高开发效率。其步骤如下所示： 需求分析：要求准确描述用户需要达到的功能，给出分析结果和需求规格说明书。 概要设计：项目架构的搭建，描述各个功能模块，描述各个接口和数据传递。 详细设计：对各个模块进行详细分析，要求达到伪代码级别，根据需求给出数据库设计。 软件编码：编写实际代码。 单元测试：按照设定，按最小测试单元进行测试，可以是具体的模块测试，或者是某个类或方法的测试。 集成测试：将各个单元组合成完整的体系，主要测试各个模块之间协调工作情况，检查接口和数据传递的准确性。 系统测试：按照软件规格说明书，检测系统是否符合用户需求，检测系统存在的问题。 验收测试：在系统使用现场进行相应测试。 增量模型增量模型（Incremental Model）也称为渐增模型，属于传统的软件开发模型。该模型如下图所示，包括：计划阶段、第N阶段（需求、设计、编码、测试、发布等子过程）、发布阶段、实施阶段、运行维护阶段等，每个线性序列代表一个阶段的增量，且每个序列的最终产物都是一个可发布的增量，其中第一阶段增量通常是核心产品。 增量模型拥有以下几种特点： 人员分配灵活，根据不同阶段的不同需求，投入适当的人力资源。 需求分段确定，逐步集成并优化需求，针对不同阶段需求可以并行分析和开发。 阶段性交付，更快给用户提供可交付的产物，优先推出核心产品。 增量模型有如下缺点： 由于各个构件是逐渐并入已有的软件体系结构中的，所以加入构件必须不破坏已构造好的系统部分，这需要软件具备开放式的体系结构。 在开发过程中，需求的变化是不可避免的。增量模型的灵活性可以使其适应这种变化的能力大大优于瀑布模型和快速原型模型，但也很容易退化为边做边改模型，从而使软件过程的控制失去整体性。 如果增量包之间存在相交的情况且未很好处理，则必须做全盘系统分析，这种模型将功能细化后分别开发的方法较适应于需求经常改变的软件开发过程。 原型模型原型模型（Prototype Model）属于传统的软件开发模型，通过快速实现一个可执行程序，来进一步确定用户需求。原型相比瀑布模型能够更准确定义用户需求，因为用户能够通过原型提供反馈，减少由于需求不明确所带来的风险。 通常快速原型包括以下两种： 抛弃型：仅为了获取需求，可能并不是通过程序代码实现的原型，因此使用后无需保留。 渐进型：原型是最终产品的一部分，通过程序代码实现。因为能够满足用户部分需求，因此会在原型基础上进一步开发。 原型模型的最大特征在于前期提供一个快速可交互原型，用户使用原型能够提供评价和反馈，帮助确认用户的正确需求。其余部分与瀑布模型相似，但是整个周期可能会更短。有时为了快速得到原型，可能会使用不合适的算法或工具来开发原型，导致开发人员可能需要抛弃多个原型来寻找正确的需求，浪费资源和时间。渐进型原型开发无法保证产品质量。 螺旋模型螺旋模型属于传统的软件开发模型，螺旋模型将瀑布模型和原型模型结合，并加入了两种模型均忽略的风险分析。螺旋模型如下图所示，主要由四个象限和向外螺旋的螺旋线组成。每轮螺旋包含四个步骤（也就是四个象限）： 决定目标、方案和限制。 风险识别和化解，评价方案。 开发并验证当前阶段产品。 客户评估。 一轮步骤结束后，开发人员需要规划并确认执行下一阶段。每个阶段包含以下几种方法步骤，每个阶段执行前都需要明确指定目标和方案： 第一阶段：原型开发，制定需求计划和生存期计划。 第二阶段：分析风险并改进原型，获取并确认软件需求，制定开发计划。 第三阶段：分析风险并改进原型，进行逻辑设计，并验证、组装和测试逻辑。 第四阶段：分析风险并组装可运行原型，进行详细设计，编码、测试、组装与实现交付。 螺旋模型拥有以下几种特点： 风险驱动，关注并分析风险，根据决策确定是否继续进行项目。 分段构建大型系统，简化成本计算。 客户能够参与每个阶段开发，保证项目不偏离以及项目可控性。 良好的沟通与评估过程，根据修正建议确保高质量的产出物。 螺旋模型适用于需求难以获取并且拥有较大风险的大型软件项目的开发，或者是适用于公司内部的大型项目的开发。螺旋模型中提出的风险评估，需要说服用户去相信这种风险，然而往往说服工作不容易展开。而且风险分析过程占用的资源、时间以及成本不能过分影响项目利润，否则风险分析毫无意义。开发人员需要寻找尽可能发生的风险，并准确分析，否则会带来更大的风险。同时螺旋模型的开发周期较长，等项目完成时，可能会造成技术落后的问题。 敏捷开发模型敏捷开发要从敏捷宣言说起，敏捷宣言主张的是消除开发过程带来的浪费，让开发者的努力体现更多的价值，是一种价值驱动思想。为了消除浪费，敏捷宣言讲述了四个观点： 可工作的软件远远比完备的文档重要。 与客户的协作沟通远远比合同谈判重要。 队员之间的互动远远比固定的流程和工具重要。 拥抱变化远远比遵循计划重要。 敏捷开发思想是精益思想（Lean Thinking）在IT领域中的应用。敏捷开发思想带动了许多实践，这些实践可能不属于同一级别的领域，但可以说都是敏捷开发包含的内容： 测试驱动、领域驱动、结对编程、持续集成、持续交付、重构、Scrum、XP等开发方式。 敏捷开发的核心思想就是短期快速迭代和自适应调整。 所谓的迭代，就是定期开发出可工作的软件并搜集反馈，然后做出相应的调整，行程反馈循环。 所谓的自适应，就是指团队内紧密合作，并根据实际情况及时调整，而不是严格按照计划和流程开发。 敏捷开发可以是一种过程控制论，也就是做事情的方法： 适用于软件，软件可塑性强。 适用于未知的需求，通过反复沟通和倾听反馈来持续改进。 适用于快节奏的开发过程和市场竞争，能够先于竞争对手完成开发，或者快速转变开发方向。 适用于小团队，这样能实现队员之间的面对面交流。 敏捷开发可以是一套工具集，即我们可以不完全去搞敏捷，但是可以用其中的某些工具来提升效率。 站会：即站立会议，简洁有效的沟通方式。 看板：反映工作进度、流程遵守情况和流程缺陷。 演示、计划和反思会：优化协作和反馈内容。 用户故事：站在用户的角度讲需求。 持续集成：随时交付高质量产物，以便于应对变化剧烈的环境。 敏捷开发还可以是企业管理方式： 队员可以有多种身份，例如一个队员可以是架构师、Scrum Master、开发工程师甚至是测试工程师。能够发挥队员的主观能动性，提高团队内部的灵活性，有利于创新和提高效率。 不专注于个人的绩效考核，侧重于整个敏捷团队的绩效考核，避免了基于KPI的驱动模式。 将大项目拆分成小项目去做，把bug的生存周期控制在一个迭代以内，降低风险。 将大团队分成小团队，划分之后由这几个小团队的Scrum Master和PO（Product Owner）组成更高一级的敏捷团队，利用敏捷开发工具集，迅速解决小问题，避免大企业病。 老板可以是PO（Product Owner），给下面的高管讲Idea（也就是用户故事），定期检查Demo，把控产品体验。 传统开发与敏捷开发之间的区别两种开发之间的核心区别的总结如下所示： 传统开发模型是预见性方法论；敏捷开发以迭代方式推进。 传统开发的前期只有各类文档；敏捷开发随时都可以有发布的软件。 传统开发的需求修改的时间越靠后，成本越大；敏捷开发不会有这种问题。 传统开发对文档要求较高；敏捷开发提倡轻文档，必要时通过文档整理思路，加快沟通和讨论。 增量开发和敏捷开发都强调较短周期提交软件，但是增量开发的开发过程中不允许修改需求。]]></content>
      <categories>
        <category>软件过程</category>
        <category>过程模型</category>
      </categories>
      <tags>
        <tag>软件过程</tag>
        <tag>传统过程模型</tag>
        <tag>瀑布流模型</tag>
        <tag>敏捷过程模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ORB_SLAM2 在 Windows 下编译]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%2F%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%2Forb-slam2%2F</url>
    <content type="text"><![CDATA[本文是针对ORB_SLAM2在Windows操作系统上如何编译和运行的一些说明。主要步骤说明在编译流程一节。 参考资料[1]《深入理解图优化与g2o》[2]《Yarten - CSDN博客》[3]《Fix Visual Studio 2013 crashes #56 - g2o/issues》[4]《Fatal Error C1001》 必要组件编译ORB_SLAM2之前需要以下第三方组件，这些组件可以从Github上克隆： Eigen3：用来进行线性代数、矩阵、向量操作等运算的C++类库，基于模板因此没有.lib文件，只需引入头文件。 OpenCV：用来处理计算机图像且包含计算机视觉算法的C++类库。 DBoW2：用于将图像转换为低维向量的压缩信息的类库，通过这种方式能够更简单比较两个图像之间的相似度。 g2o：用于图优化的C++类库。 Pangolin：基于OpenGL的封装类库，能够处理视频输入和输出。 可选组件由于ORB_SLAM2中自带了修改过的DBoW2和g2o库，如果需要自己去克隆和编译（不推荐）DBoW2和D Boost：STL的延伸，基于STL提供的算法封装工具类，可以用于完成比较具体的工作。 编译基础在Windows操作系统上进行编译时，需要注意以下几点： 检查工程文件内的CMakeList.txt文件，如果存在FIND_PACKAGE语句则直接删除。对于TARGET_LINK_LIBRARIES和INCLUDE_DIRECTORIES等指令，可以将里面包含的CMake变量改成系统环境变量（即$ENV{}格式的变量）。 使用CMake构建工程时，尽量构建X64模式的工程，如下通过Win64的方式来指定目标平台： 12# ../src/buildcmake .. -G "Visual Studio 15 2017 Win64" 在编译之前，确保项目属性中C/C++标签内的命令行选项、链接器（或者库管理器）标签内的命令行选项内是否包含/machine参数，需要统一成/machine:X64。 编译流程安装CMakeCMake作为一种项目管理工具，可以从官方网站下载和安装。安装后可以通过命令提示符或图形界面（CMake GUI）来针对克隆下来的CMakeList.txt进行项目构建。CMake的具体使用方式可以参考CMake教程。 编译OpenCV编译OpenCV的过程通常没有太多的问题，只需要注意在Release X64模式下编译成功，并且使用多线程MT运行库。实际上目前还是推荐从OpenCV官网上下载最新版的编译好的二进制文件。 编译Pangolin编译Pangolin的过程建议通过以下步骤进行： 通过CMake构建X64工程文件，注意如果提示file problem creating directory错误，需要手动去C:/Program Files文件夹内新建Pangolin文件夹。 构建完毕后，确保使用管理员权限打开工程文件，这样才能确保__glew、__zlib、__libjpeg、__libpng等工程正确编译，防止出现MSB3073错误。 选择目标为Relase X64，运行库设置为多线程MT，并且将pangolin项目设为启动项目。 设置pangolin的附加包含目录，如下，其中${Pangolin}代表克隆后的Pangolin工程根目录： ${Pangolin}/include ${Pangolin}/build/src/include C:/Program Files/Pangolin/include，该文件夹为空，可以不包含。 ${Pangolin}/build/external/glew/src/__glew/include，如果不包含不提示错误，可以不包含。 右键点击重新生成，或者点击本地Windows调试器，进行Pangolin的生成过程。 编译过程中可能会发生以下的问题： C1083 无法打开包括文件：jconfig.h：No such file or directory 解决方法：将${Pangolin}/build/external/libjpeg/src/__libjpeg/文件夹内的jconfig.txt文件改成jconfig.h。 C1083 无法打开包括文件：pnglibconf.h：No such file or directory 解决方法：从Github上获取pnglibconf.h文件，并放到${Pangolin}/build/external/libpng/src/__libpng文件夹中。 编译Eigen3该工程是基于模板的工程，只需要作为包含目录引用即可，不需要进行编译和引用依赖库。 编译DBoW2这里建议使用ORB_SLAM2自带的DBoW2类库，该类库针对ORB_SLAM2进行了修改。而编译该类库需要以下几种步骤： 通过CMake构建X64工程文件，注意构建之前在CMakeList.txt文件中寻找有关OpenCV的FIND_PACKAGE指令并删除，然后建议通过INCLUDE_DIRECTORIES和TARGET_LINK_LIBRARIES指令中添加OpenCV的包含目录和依赖库目录。 打开工程文件，选择目标为Release X64，运行库设置为多线程MT，在命令行中，并且将DBoW2设置为启动项目。 确保OpenCV的头文件和依赖库正确添加。 创建并编写一个DBoW2Exports.h头文件用于API声明，如下，使用宏定义之前需要保证在工程属性的预处理器一项中添加预处理器定义DBOW2_EXPORTS来确保API声明生效： 123456#pragma once#ifdef DBOW2_EXPORTS#define DBOW2_API __declspec(dllexport)#else#define DBOW2_API __declspec(dllimport)#endif 对工程内的头文件添加API声明，针对以下类型将声明class XXX改为class DBOW2_API XXX： BowVector.h：修改BowVector类。 FeatureVector.h：修改FeatureVector类。 FORB.h：修改FORB类。 Random.h：修改Random、UnrepeatedRandomizer等类。 ScoringObjects.h：修改GeneralScoring类型，并且修改所有前缀为__SCORING_CLASS宏的类型。 Timestamp.h：修改Timestamp类。 右键点击DBoW2项目并重新生成，或者点击本地Windows调试器来编译工程。 编译过程中可能会发生以下问题： C1083 无法打开包括文件：stdint-gcc.h：No such file or directory 解决方法：将stdint-gcc.h改为stdint.h。 编译g2o这里建议使用ORB_SLAM2自带的g2o类库，该类库针对ORB_SLAM2进行了修改。而编译该类库需要以下几种步骤： 通过CMake构建X64工程文件，注意构建之前在CMakeList.txt文件中寻找有关Eigen的FIND_PACKAGE指令并删除，然后建议通过INCLUDE_DIRECTORIES和TARGET_LINK_LIBRARIES指令中添加Eigen的包含目录。 打开工程文件，选择目标为Release X64，运行库设置为多线程MT，并且将g2o设置为启动项目。 打开C/C++中的命令行页面，删除/W参数。 找到sparse_block_matrix.hpp、sparse_block_matrix_diagonal.h、matrix_operations.h等文件，修改如下模板函数，避免Visual Studio在编译过程中无法识别具体类型而报C1001错误： 1234567// sparse_block_matrix.hpp, Line 273// internal::axpy(*a, srcVec, srcOffset, destVec, destOffset);internal::template axpy&lt;typename SparseBlockMatrix&lt;MatrixType&gt;::SparseMatrixBlock&gt;(*a, srcVec, srcOffset, destVec, destOffset);// sparse_block_matrix.hpp, Line 275// internal::atxpy(*a, srcVec, destOffset, destVec, srcOffset);internal::template atxpy&lt;typename SparseBlockMatrix&lt;MatrixType&gt;::SparseMatrixBlock&gt;(*a, srcVec, destOffset, destVec, srcOffset);// matrix_operations.h, 49 如果存在matrix_operations.h文件，则按照第四步的步骤在文档中查找axpy()和atxpy()，并且同样修改成第四步中指定的内容。 修改config.h头文件用于API声明（如果config.h不存在，则将config.txt后缀改为.h），如下，使用宏定义之前需要保证在工程属性的预处理器一项中添加预处理器定义G2O_EXPORTS来确保API声明生效： 123456#pragma once#ifdef G2O_EXPORTS#define G2O_API __declspec(dllexport)#else#define G2O_API __declspec(dllimport)#endif 对工程内的头文件引入config.h且添加API声明，针对类型声明class XXX改为class G2O_API XXX，结构体声明struct XXX改为struct G2O_API XXX，注意这里只需要对有对应.cpp而没有对应.hpp文件的头文件进行修改即可： bathc_stats.h：修改G2OBatchStatistics结构体。 cache.h：修改CacheContainer、Cache等类。 creators.h：修改AbstractHyperGraphElementCreator、HyperGraphElementCreator等类。 estimate_propagator.h：修改EstimatePropagatorCost、EstimatePropagatorCostOdometry、EstimatePropagator等类。 factory.h：修改AbstractHyperGraphElementCreator、Factory、RegisterTypeProxy等类。 hyper_dijkstra.h：修改HyperDijkstra、UniformCostFunction等结构体。 hyper_graph.h：修改HyperGraph类。 hyper_graph_action.h：修改HyperGraphAction、HyperGraphElementAction、HyperGraphElementActionCollection、HyperGraphActionLibrary、WriteGnuplotAction、DrawAction等类型，修改RegisterActionProxy模板类。 jacobian_workspace.h：修改OptimizableGraph、JacobianWorkspace等类。 marginal_covariance_cholesky.h：修改MarginalCovarianceCholesky类。 matrix_structure.h：修改MatrixStructure类。 openmp_mutex：修改OpenMPMutex、ScopedOpenMPMutex等类。 optimizable_graph.h：修改OptimizableGraph结构体，修改HyperGraphAction、OptimizationAlgorithmProperty、Cache、CacheContainer、RobustKernel等类型。 optimization_algorithm.h：修改SparseOptimizer、OptimizationAlgorithm等类型。 optimization_algorithm_factory.h：修改OptimizationAlgorithm、SparseOptimizer、AbstractOptimizationAlgorithmCreator、OptimizationAlgorithmFactory、RegisterOptimizationAlgorithmProxy等类型。 optimization_algorithm_levenberg.h：修改OptimizationAlgorithmLevenberg等类型。 optimization_algorithm_with_hessian.h：修改Solver、OptimizationAlgorithmWithHessian等类型。 parameter.h：修改Parameter类。 parameter_container.h：修改Parameter、ParameterContainer等类。 property.h：修改BaseProperty、PropertyMap等类，修改Property模板类型。 robust_kernel.h：修改RobustKernel类。 robust_kernel_factory.h：修改RobustKernel、AbstractRobustKernelCreator、RobustKernelFactory等类型，修改RobustKernelCreator、RegisterRobustKernelProxy等模板类。 robust_kernel_impl.h：修改RobustKernelScaleDelta、RobustKernelHuber、RobustKernelTukey、RobustKernelPseudoHuber、RobustKernelCauchy、RobustKernelSaturated、RobustKernelDCS等类型。 solver.h：修改SparseOptimizer、Solver等类型。 sparse_optimizer.h：修改ActivePathCostFunction、OptimizationAlgorithm、EstimatePropagatorCost、SparseOptimizer等类型。 types_sba.h：修改VertexSBAPointXYZ类。 types_seven_dof_expmap.h：修改VertexSim3Expmap、EdgeSim3、EdgeSim3ProjectXYZ、EdgeInverseSim3ProjectXYZ等类型。 types_six_dof_expmap.h：修改VertexSE3Expmap、EdgeSE3ProjectXYZ、EdgeStereoSE3ProjectXYZ、EdgeSE3ProjectXYZOnlyPose、EdgeStereoSE3ProjectXYZOnlyPose等类型。 右键点击g2o项目并重新生成，或者点击本地Windows调试器来编译工程。 编译ORB_SLAM2编译ORB_SLAM2过程如下： 通过CMake构建X64工程文件，删除所有FIND_PACKAGE指令。 打开工程文件，选择目标为Release X64，运行库设置为多线程MT，命令行输入/machine:X64，并且将ORB_SLAM2设置为启动项目。 确认和添加相应的头文件包含目录，按顺序排列主要有： ORB_SLAM2自身的包含目录。 Eigen3的包含目录。 Pangolin的包含目录，包括${Pangolin}/include、${Pangolin}/build/src/include等目录。 DBoW2自身的包含目录和DLib的包含目录。 OpenCV的三个包含目录，也可以是一个目录但是需要调整源代码。 glew的包含目录。 g2o的包含目录，注意需要包含config.h文件。 确认和添加相应的库目录和依赖库文件，按顺序排列主要有： 系统内置依赖库，包括opengl32.lib、glu32.lib、mfplat.lib、mfreadwrite.lib、mfuuid.lib、strmiids.lib、mf.lib。 OpenCV的X64位库目录，包括opencv_world341.lib。 Pangolin工程内包含的glew库目录，包括glew.lib。 Pangolin库目录、包括pangolin.lib。 ORB_SLAM2内包含的DBoW2库目录，包括DBoW2.lib。 ORB_SLAM2内包含的g2o库目录，包括g2o.lib。 右键点击ORB_SLAM2项目并重新生成，或者点击本地Windows调试器来编译工程。 编译过程中可能会发生以下问题： 表达式必须含有常量值不可指定数组类型float [N][N] 解决方法：VC++中不允许用运行时常量去定义数组长度，因此需要进行如下修改，动态创建二维数组：12345float** Distances = new float*[N];for(int i = 0; i &lt; N; i++)&#123; Distance[i] = new float[N];&#125; ‘usleep’找不到标识符 解决方法：usleep()是在Linux上使用的函数，需要修改成以下函数中的一种：123#include &lt;thread&gt;Sleep(3000); // 单位为毫秒，需要换算微秒std::this_thread::sleep_for(std::chrono::microseconds(m)); // 可以直接替换usleep() C1083 无法打开包括文件：stdint-gcc.h：No such file or directory 解决方法：将stdint-gcc.h改为stdint.h。 C1001 编译器内部错误 解决方法：仍然是由于g2o模块中的axpy()和atxpy()方法造成的错误，请参考上方编译g2o中的第四步。 C2872 “ACCESS_MASK” 不明确的符号 解决方法：由于winnt.h和OpenCV都定义了ACCESS_MASK，如果使用using namespace cv会导致混淆，因此只能以using cv::XXX的形式引用命名空间。 示例可以在ORB_SLAM2项目中添加Main.cpp以及主函数，并且修改工程的输出类型为应用程序，最后可编译成基于ORB_SLAM2的可执行程序。 基于SLAM的AR示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;opencv2/core/core.hpp&gt;#include &lt;opencv2/imgproc/imgproc.hpp&gt;#include "System.h"#include "ViewerAR.h"using namespace ORB_SLAM2;using cv::VideoCapture;using cv::Mat;using cv::FileStorage;ORB_SLAM2::ViewerAR ar;bool bRGB = true;Mat K;Mat DistCoef;class ImageGrabber&#123;public: ImageGrabber(System* pSLAM) : mpSLAM(pSLAM)&#123;&#125; void GrabImage(const cv::Mat&amp; msg); System* mpSLAM;&#125;;int main()&#123; char* arg1 = "F:\\SLAM\\Source\\ORB_SLAM2\\Vocabulary\\ORBvoc.txt"; char* arg2 = "F:\\SLAM\\Source\\ORB_SLAM2\\Examples\\Monocular\\TUM2.yaml"; System orbslam(arg1, arg2, System::eSensor::MONOCULAR, true); ImageGrabber igb(&amp;orbslam); ar.SetSLAM(&amp;orbslam); FileStorage fSettings(arg2, FileStorage::READ); bRGB = static_cast&lt;bool&gt;((int)fSettings["Camera.RGB"]); float fps = fSettings["Camera.fps"]; ar.SetFPS(fps); float fx = fSettings["Camera.fx"]; float fy = fSettings["Camera.fy"]; float cx = fSettings["Camera.cx"]; float cy = fSettings["Camera.cy"]; ar.SetCameraCalibration(fx, fy, cx, cy); K = Mat::eye(3, 3, CV_32F); K.at&lt;float&gt;(0, 0) = fx; K.at&lt;float&gt;(1, 1) = fy; K.at&lt;float&gt;(0, 2) = cx; K.at&lt;float&gt;(1, 2) = cy; DistCoef = cv::Mat::zeros(4, 1, CV_32F); DistCoef.at&lt;float&gt;(0) = fSettings["Camera.k1"]; DistCoef.at&lt;float&gt;(1) = fSettings["Camera.k2"]; DistCoef.at&lt;float&gt;(2) = fSettings["Camera.p1"]; DistCoef.at&lt;float&gt;(3) = fSettings["Camera.p2"]; const float k3 = fSettings["Camera.k3"]; if (k3 != 0) &#123; DistCoef.resize(5); DistCoef.at&lt;float&gt;(4) = k3; &#125; thread tViewer = thread(&amp;ORB_SLAM2::ViewerAR::Run, &amp;ar); VideoCapture cap(0); Mat frame; bool stop = false; while (!stop) &#123; cap &gt;&gt; frame; igb.GrabImage(frame); if (cvWaitKey(30) &gt;= 0) &#123; stop = true; &#125; &#125; system("pause"); delete arg1; delete arg2; return 0;&#125;void ImageGrabber::GrabImage(const Mat&amp; msg)&#123; Mat im = msg.clone(); Mat imu; Mat Tcw = mpSLAM-&gt;TrackMonocular(msg, 0); int state = mpSLAM-&gt;GetTrackingState(); mpSLAM-&gt;TrackMonocular(msg, clock()); vector&lt;ORB_SLAM2::MapPoint*&gt; vMPs = mpSLAM-&gt;GetTrackedMapPoints(); vector&lt;cv::KeyPoint&gt; vKeys = mpSLAM-&gt;GetTrackedKeyPointsUn(); cv::undistort(im, imu, K, DistCoef); if (bRGB) &#123; cv::cvtColor(imu, imu, CV_RGB2BGR); ar.SetImagePose(imu, Tcw, state, vKeys, vMPs); &#125; else &#123; cv::cvtColor(imu, imu, CV_RGB2BGR); ar.SetImagePose(imu, Tcw, state, vKeys, vMPs); &#125;&#125; 文件解析 cv_bridge.h：ROS图像与OpenCV图像之间的转换]]></content>
      <categories>
        <category>计算机科学</category>
        <category>机器视觉</category>
      </categories>
      <tags>
        <tag>ORB_SLAM2</tag>
        <tag>SLAM</tag>
        <tag>机器视觉</tag>
        <tag>计算机科学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ViewRO知识库首页]]></title>
    <url>%2Funcategorized%2Fhome%2F</url>
    <content type="text"><![CDATA[欢迎来到ViewRO知识库首页，该页面旨在分享一些知识。这些知识大多来自于互联网，其余部分来自各种书籍。部分内容可能会比较初级，目的在于统一编辑和方便查找，利于内部人员和感兴趣的人避免踩坑。主要分享计算机相关的知识，未来会分享不同领域的内容。提前感谢各位巨人，一切都是因为站在巨人的肩膀上，所以才能看的更远。希望您活用本站内容。]]></content>
  </entry>
</search>
